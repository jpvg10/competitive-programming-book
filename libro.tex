\documentclass{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{multicol}
\usepackage{geometry}

\lstset{
	language=java,
	numberstyle=\tiny, 
	breaklines=true,
	numbersep=1pt,
	tabsize=2,
	xleftmargin=.01in,
	xrightmargin=.01in,
	postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
	numbers=left
}

\geometry{landscape,letterpaper,tmargin=1.5cm,bmargin=2cm,lmargin=1.6cm,rmargin=1.6cm}
\setlength{\columnsep}{0.25in}
\setlength{\columnseprule}{1px}

\begin{document}

\begin{multicols}{2}

\tableofcontents

\section{Mapas}
Estructura de datos que guarda pares \emph{(clave, valor)}. El HashMap no pone las claves en ningún orden en particular. TreeMap ordena las claves de acuerdo a su orden natural. LinkedHashMap pone las claves en el orden en que se ingresen.

Las operaciones .put(), .get() y .containsKey() son \( O(1) \) en HashMap y LinkedHashMap, y \( O(\log n) \) en TreeMap.
\lstinputlisting[firstline=7, lastline=30]{./src/Mapas.java}

\section{Sets}
Estructura de datos que actúa como ``bolsa'' donde se almacenan elementos, pero no puede almacenar elementos duplicados.

En HashSet .add() y .contains() son \( O(1) \), mientras que en TreeSet son \( O(\log n) \). Sin embargo, en el TreeSet los elementos quedan ordenados.
\lstinputlisting[firstline=5, lastline=19]{./src/Sets.java}

\section{Grafos}
	\subsection{BFS y DFS}
	Recorren un grafo a partir de un nodo origen y visitan todos los nodos alcanzables desde éste. Ambos algoritmos tienen un tiempo de ejecución de \( O(n + m) \) donde \( n \) es el número de nodos y \( m \) es el número de aristas del grafo. El siguiente ejemplo está con DFS pero funciona igual con BFS.	
	\lstinputlisting[firstline=7, lastline=65]{./src/Grafos.java}

	\subsection{Shortest Hop}
	Modificación de BFS que calcula el camino más corto desde un nodo origen \( s \) a todos los demás. Sólo funciona cuando el peso de todas las aristas es 1. Su tiempo de ejecución es el mismo de BFS: \( O(n + m) \).
	\lstinputlisting[firstline=7, lastline=53]{./src/ShortestHop.java}
	
	\subsection{Ordenamiento Topológico}
	Todo grafo dirigido acíclico (DAG) tiene un ordenamiento topológico. Esto significa que para todas las aristas \( (u,v) \), \(u\) aparece en el ordenamiento antes que \(v\). Visualmente es como si se pusieran todos los nodos en línea recta y todas las aristas fueran de izquierda a derecha, ninguna de derecha a izquierda. En realidad es una modificación de DFS y su tiempo de ejecución es el mismo: \( O(n + m) \). El método retorna falso si detecta un ciclo en el grafo, ya que en este caso no existe ordenamiento topológico posible.
	\lstinputlisting[firstline=6, lastline=56]{./src/TopoSort.java}
	
	\subsection{Componentes Fuertemente Conexas (Algoritmo de Tarjan)}
	Calcula la componente fuertemente conexa a la que pertenece cada nodo de un grafo dirigido. Si dos nodos \( u, v \) están en la misma componente, significa que existe un camino de \( u \) a \( v \) y uno de \( v \) a \( u \). Su tiempo de ejecución es \( O(n + m) \).
	\lstinputlisting[firstline=6, lastline=68]{./src/Tarjan.java}
	
	\subsection{Puntos de Articulación}
	Halla los puntos de articulación de un grafo. Un punto de articulación es un nodo del grafo que si se quitara causaría que el grafo se ``desconectara''. Si el grafo no era conexo en un principio, un punto de articulación es un nodo que si se quitara incrementaría el número de componentes conexas. El tiempo de ejecución del algoritmo es \( O(n + m) \).
	\lstinputlisting[firstline=5, lastline=62]{./src/ArticulationPoints.java}
	
	\subsection{Puentes}
	Halla los puentes de un grafo.  Un puente es una arista del grafo que si se quitara causaría que el grafo se ``desconectara''. Si el grafo no era conexo en un principio, un puente es una arista que si se quitara incrementaría el número de componentes conexas. El tiempo de ejecución del algoritmo es \( O(n + m) \).
	\lstinputlisting[firstline=3, lastline=72]{./src/GraphBridges.java}
	
	\subsection{Algoritmo de Dijkstra}
	Halla la distancia más corta desde un nodo origen \emph{src} hacia todos los demás nodos. Funciona con grafos dirigidos y no dirigidos, siempre y cuando los pesos de las aristas sean no-negativos. Su tiempo de ejecución es \( O(m + n\log n) \)
	\lstinputlisting[firstline=5, lastline=76]{./src/Dijkstra.java}
	
	\subsection{Algoritmo de Floyd-Warshall}
	Halla la distancia más corta desde todos los nodos hacia todos los demás. El grafo debe estar representado en matriz de adyacencia.

\section{El problema de la mochila (Knapsack)}
Se tiene una mochila con capacidad \( W \), y \( n \) items con un peso \( w_i \) y un valor \( v_i \) cada uno. Se quiere hallar el conjunto de items que maximicen el valor total pero cuyos pesos no excedan \( W \). Su tiempo de ejecución es \( O(nW) \). Es posible indicar cuál es el mayor valor posible, y con un ciclo adicional, indicar exactamente cuáles items se seleccionaron.
\lstinputlisting[firstline=4, lastline=45]{./src/Knapsack.java}

\section{KMP}
Algoritmo para buscar una cadena \emph{pattern} dentro de una cadena \emph{text}. Su tiempo de ejecución es de \( O(m+n) \) donde \( m \) es la longitud de \emph{text} y \( n \) es la longitud de \emph{pattern}. Retorna la posición donde inicia la primera ocurrencia de \emph{text} dentro de \emph{pattern}, o -1 si no existe.
\lstinputlisting[firstline=4, lastline=51]{./src/KMP.java}

\section{Union-Find}
Estructura de datos que soporta las siguientes operaciones eficientemente:
\begin{itemize}
\item Unir dos elementos \( p, q \), es decir, indicar que pertenecen al mismo conjunto
\item Determinar si dos elementos \( p, q \) pertenecen al mismo conjunto o no
\end{itemize}
\lstinputlisting[firstline=2, lastline=66]{./src/UnionFind.java}

\section{Teoría de números}
	\subsection{Algoritmo de Euclides}
	Se utiliza para hallar el máximo común divisor (MCD) entre dos números. También se puede usar para hallar el mínimo común múltiplo (MCM).
	\lstinputlisting[firstline=3, lastline=15]{./src/Euclides.java}

	\subsection{Verificar si un número es primo}
	Dependiendo del problema, puede que nos sirva la forma ``fuerza bruta''. Esta forma tiene una complejidad de \( O(\sqrt{n}) \). Sin embargo, si tenemos números de más de 64 bits (que no caben en un \emph{long}) ya esta forma no es viable. 
	
	La clase BigInteger provee un método probabilístico para determinar si un número es primo. Si el número es compuesto, el método retona \emph{false} siempre. Si el método retorna \emph{true}, hay una probabilidad de \( 1-\frac{1}{2^x} \) de que el número sea primo, donde \(x\) es un parámetro que se le pasa a la función. Generalmente un valor de \(x = 10\) está bien.
	\lstinputlisting[firstline=5, lastline=27]{./src/CheckPrime.java}

	\subsection{Criba  de Eratóstenes}
	Algoritmo para hallar los números primos menores o iguales a \( n \). Su tiempo de ejecución es \( O(n \log \log n) \).
	\lstinputlisting[firstline=6, lastline=24]{./src/Sieve.java}
	
	\subsection{Factorización prima de un número}
	Retorna un HashMap donde la \emph{clave} es el factor primo y el \emph{valor} su multiplicidad.
	\lstinputlisting[firstline=24, lastline=46]{./src/Sieve.java}	
	
	\subsection{Los \(n\) primeros números primos}
	Si queremos hallar los primeros \( n \) números primos, la Criba de Eratóstenes	no nos puede ayudar, porque no sabemos hasta dónde tenemos que buscar. Con este método se optimiza un poco el acercamiento ``fuerza bruta'' a este problema.	
	\lstinputlisting[firstline=5, lastline=33]{./src/GeneratePrimes.java}	
		
\section{Otros}
	\subsection{Ordenamiento de Arrays y Listas}
	Cuando necesite ordenar un vector o una lista, utilice los métodos .sort() que tiene 		Java. El algoritmo que utilizan es QuickSort y su tiempo de ejecución es de \( O(n\log n) \).	
	\lstinputlisting[firstline=7, lastline=25]{./src/Sorting.java}
	
	\subsection{Imprimir números decimales redondeados}
	Generalmente basta con esta función de Java para redondear correctamente números decimales.	
	\lstinputlisting[firstline=4, lastline=9]{./src/Redondear.java}
	
	\subsection{BufferedReader y BufferedWriter}
	\emph{Scanner} es sencillo de utilizar pero es lento. Se recomienda utilizar siempre \emph{BufferedReader} para leer entradas.
	
	En algunas ocasiones también se necesitará un modo más rápido que \emph{System.out.println()} para imprimr. \emph{BufferedWriter} es más rápido, nunca está de más usarlo.
	\lstinputlisting[firstline=9, lastline=23]{./src/ReaderWriter.java}
\end{multicols}	
\end{document}