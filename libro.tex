\documentclass{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{multicol}
\usepackage{geometry}
\usepackage{amsmath}

\lstset{
	language=java,
	numberstyle=\tiny, 
	breaklines=true,
	numbersep=1pt,
	tabsize=2,
	xleftmargin=.01in,
	xrightmargin=.01in,
	postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
	numbers=left
}

\geometry{landscape,letterpaper,tmargin=1.5cm,bmargin=2cm,lmargin=1.6cm,rmargin=1.6cm}
\setlength{\columnsep}{0.25in}
\setlength{\columnseprule}{1px}

\begin{document}

\begin{multicols}{2}

\tableofcontents

\section{Mapas}
Estructura de datos que guarda pares \emph{(clave, valor)}. El HashMap no pone las claves en ningún orden en particular. TreeMap ordena las claves de acuerdo a su orden natural. LinkedHashMap pone las claves en el orden en que se ingresen.

Las operaciones .put(), .get() y .containsKey() son \( O(1) \) en HashMap y LinkedHashMap, y \( O(\log n) \) en TreeMap.
\lstinputlisting[firstline=7, lastline=30]{./src/Mapas.java}

\section{Sets}
Estructura de datos que actúa como ``bolsa'' donde se almacenan elementos, pero no puede almacenar elementos duplicados.

En HashSet .add() y .contains() son \( O(1) \), mientras que en TreeSet son \( O(\log n) \). Sin embargo, en el TreeSet los elementos quedan ordenados.
\lstinputlisting[firstline=5, lastline=19]{./src/Sets.java}

\section{Union-Find}
Estructura de datos que soporta las siguientes operaciones eficientemente:
\begin{itemize}
\item Unir dos elementos \( p, q \)
\item Determinar si dos elementos \( p, q \) pertenecen al mismo conjunto o no
\end{itemize}
\lstinputlisting[firstline=2, lastline=66]{./src/UnionFind.java}

\section{Grafos}
	\subsection{BFS y DFS}
	Recorren un grafo a partir de un nodo origen y visitan todos los nodos alcanzables desde éste. Ambos algoritmos tienen una complejidad de \( O(n + m) \) donde \( n \) es el número de nodos y \( m \) es el número de aristas del grafo. El siguiente ejemplo está con DFS pero funciona igual con BFS.	
	\lstinputlisting[firstline=7, lastline=65]{./src/Grafos.java}

	\subsection{Shortest Hop}
	Modificación de BFS que calcula el camino más corto desde un nodo origen \( s \) a todos los demás. Sólo funciona cuando el peso de todas las aristas es 1. Su complejidad es la misma de BFS: \( O(n + m) \).
	\lstinputlisting[firstline=7, lastline=53]{./src/ShortestHop.java}
	
	\subsection{Ordenamiento topológico}
	Todo grafo dirigido acíclico (DAG) tiene un ordenamiento topológico. Esto significa que para todas las aristas \( (u,v) \), \(u\) aparece en el ordenamiento antes que \(v\). Visualmente es como si se pusieran todos los nodos en línea recta y todas las aristas fueran de izquierda a derecha, ninguna de derecha a izquierda. En realidad es una modificación de DFS y complejidad es la misma: \( O(n + m) \). El método retorna falso si detecta un ciclo en el grafo, ya que en este caso no existe ordenamiento topológico posible.
	\lstinputlisting[firstline=6, lastline=56]{./src/TopoSort.java}
	
	\subsection{Componentes fuertemente conexas (Algoritmo de Tarjan)}
	Calcula la componente fuertemente conexa a la que pertenece cada nodo de un grafo dirigido. Si dos nodos \( u, v \) están en la misma componente, significa que existe un camino de \( u \) a \( v \) y uno de \( v \) a \( u \). Su complejidad es \( O(n + m) \).
	\lstinputlisting[firstline=6, lastline=68]{./src/Tarjan.java}
	
	\subsection{Puntos de articulación}
	Halla los puntos de articulación de un grafo. Un punto de articulación es un nodo del grafo que si se quitara causaría que el grafo se ``desconectara''. Si el grafo no era conexo en un principio, un punto de articulación es un nodo que si se quitara incrementaría el número de componentes conexas. La complejidad del algoritmo es \( O(n + m) \).
	\lstinputlisting[firstline=5, lastline=62]{./src/ArticulationPoints.java}
	
	\subsection{Puentes}
	Halla los puentes de un grafo.  Un puente es una arista del grafo que si se quitara causaría que el grafo se ``desconectara''. Si el grafo no era conexo en un principio, un puente es una arista que si se quitara incrementaría el número de componentes conexas. La complejidad del algoritmo es \( O(n + m) \).
	\lstinputlisting[firstline=3, lastline=72]{./src/GraphBridges.java}
	
	\subsection{Minimum Spanning Tree (Algoritmo de Kruskal)}
	Halla el árbol de cubrimiento mínimo de un grafo no-dirigido y conexo. Utiliza la estructura de datos Union-Find discutida anteriormente. El grafo debe ser representado como una lista de objetos tipo Arista. Tiene una complejidad de \( O( m \log n) \).
	\lstinputlisting[firstline=4, lastline=45]{./src/Kruskal.java}
	
	\subsection{Algoritmo de Dijkstra}
	Halla la distancia más corta desde un nodo origen \emph{src} hacia todos los demás nodos. Funciona con grafos dirigidos y no dirigidos, siempre y cuando los pesos de las aristas sean no-negativos. Su complejidad es \( O(m + n \log n) \)
	\lstinputlisting[firstline=5, lastline=76]{./src/Dijkstra.java}
	
	\subsection{Algoritmo de Floyd-Warshall}
	Halla la distancia más corta desde todos los nodos hacia todos los demás. El grafo debe estar representado en matriz de adyacencia, y puede tener aristas con peso negativo. Sin embargo, no puede tener ciclos de peso negativo. En caso de que exista un ciclo negativo, el algoritmo lo detectará. Si todas las artistas son no-negativas, se puede omitir la comprobación del ciclo negativo.
	La matriz de adyacencia debe armarse así:
	\[
		\text{grafo}(i, j) = \left \{ 
			\begin{array}{lcc}
				0 & si & i = j
				\\ c_{i,j} & si & \text{existe una arista de } i \text{ a } j \text{ con costo } c_{i,j}
				\\ \infty & si & i \neq j \text{ y no existe arista de } i \text{ a } j 
			\end{array}
		\right.
	\]
	La complejidad del alrgoritmo es \( O(n^3) \).
	\lstinputlisting[firstline=4, lastline=48]{./src/FloydWarshall.java}

\section{KMP}
Algoritmo para buscar una cadena \emph{pattern} dentro de una cadena \emph{text}. Su complejidad es de \( O(m+n) \) donde \( m \) es la longitud de \emph{text} y \( n \) es la longitud de \emph{pattern}. Retorna la posición donde inicia la primera ocurrencia de \emph{text} dentro de \emph{pattern}, o -1 si no existe.
\lstinputlisting[firstline=4, lastline=51]{./src/KMP.java}

\section{Programación dinámica}
	\subsection{Longest Increasing Subsequence}
		Halla la longitud de la subsecuencia creciente más larga que hay en un vector (o String). También halla los elementos que pertenecen a dicha subsecuencia, por si llega a ser necesario. Su complejidad es \( O(n^2) \).
		\lstinputlisting[firstline=5, lastline=46]{./src/LIS.java}
	\subsection{Longest Common Subsequence}
		Halla la longitud de la subsecuencia común más larga entre dos Strings (o vectores). También halla los elementos que pertenecen a dicha subsecuencia, por si llega a ser necesario. Su complejidad es \( O(mn) \), donde \( m \) y \( n \) son las longitudes de los Strings.
		\lstinputlisting[firstline=4, lastline=41]{./src/LCS.java}
	\subsection{Coin Change Problem}
	\subsection{Edit Distance}
	\subsection{El problema de la mochila (Knapsack)}
	Se tiene una mochila con capacidad \( W \), y \( n \) items con un peso \( w_i \) y un valor \( v_i \) cada uno. Se quiere hallar el conjunto de items tal que la suma de sus pesos no exceda \( W \), y que la suma de sus valores sea lo más grande posible. Su complejidad es \( O(nW) \). Es posible indicar cuál es el mayor valor posible, y con un ciclo adicional, indicar exactamente cuáles items se seleccionaron.
	\lstinputlisting[firstline=4, lastline=44]{./src/Knapsack.java}

\section{Teoría de números}
	\subsection{Algoritmo de Euclides}
	Se utiliza para hallar el máximo común divisor (MCD) entre dos números. También se puede usar para hallar el mínimo común múltiplo (MCM).
	\lstinputlisting[firstline=3, lastline=15]{./src/Euclides.java}

	\subsection{Verificar si un número es primo}
	Dependiendo del problema, puede que nos sirva la forma ``fuerza bruta''. Esta forma tiene una complejidad de \( O(\sqrt{n}) \). Sin embargo, si tenemos números de más de 64 bits (que no caben en un \emph{long}) ya esta forma no es viable. 
	
	La clase BigInteger provee un método probabilístico para determinar si un número es primo. Si el número es compuesto, el método retona \emph{false} siempre. Si el método retorna \emph{true}, hay una probabilidad de \( 1-\frac{1}{2^x} \) de que el número sea primo, donde \(x\) es un parámetro que se le pasa a la función. Generalmente un valor de \(x = 10\) está bien.
	\lstinputlisting[firstline=5, lastline=28]{./src/CheckPrime.java}

	\subsection{Criba  de Eratóstenes}
	Algoritmo para hallar los números primos menores o iguales a \( n \). Su complejidad es \( O(n \log \log n) \).
	\lstinputlisting[firstline=6, lastline=25]{./src/Criba.java}
	
	\subsection{Factorización prima de un número}
	Se busca expresar un número \( n \) como una multiplicación de factores primos, de la forma:
	\[ n = \prod p_{i}^{a_{i}} = p_{1}^{a_{1}} \cdot p_{2}^{a_{2}} \cdot p_{3}^{a_{3}} ...  p_{k}^{a_{k}} \]
	
	Previamente se debe hacer una Criba de Eratóstenes modificada. Verifique en la especificación de la entrada del problema cuál es el máximo número \( x \) que tendrá que factorizar, y haga la Criba hasta \( \sqrt{x} \).
	
	El método retorna un HashMap donde la \emph{clave} es el factor primo \( p_{i} \) y el \emph{valor} su multiplicidad \( a_{i} \). Se puede modificar fácilmente para retornar una lista de todos los factores, o retornar la cantidad de factores.
	
	Con algunas modificaciones, puede funcionar más o menos hasta \( 10^{12} \).
	\lstinputlisting[firstline=7, lastline=72]{./src/Factorizar.java}
	
	\subsection{Fórmulas}
	Para \( n \geq 2 \) es posible calcular algunas cosas partiendo de la factorización prima de \( n \):
	\[ n = \prod p_{i}^{a_{i}} = p_{1}^{a_{1}} \cdot p_{2}^{a_{2}} \cdot p_{3}^{a_{3}} ...  p_{k}^{a_{k}} \]
	\( n = 1 \) es un caso especial:
	\[ d(1) = \sigma (1) = \varphi (1) = 1 \]

		\subsubsection{Cantidad de divisores}
		\[ d(n) = \prod (a_{i} + 1) \]
		
		\subsubsection{Suma de divisores}
		\[ 
			\sigma (n) = \prod \frac{p_{i}^{a_{i} + 1} - 1}{p_{i} - 1}
		\]
		Esta función toma todos los divisores. Por ejemplo, los divisores de 12 son \( \{1, 2, 3, 4, 6, 12\} \). Por ende, \( \sigma(12) = 1+2+3+4+6+12 = 28 \). Si se quiere la suma de los divisores propios (es decir, los divisores excluyendo a \( n \) ), basta con hallar:
		\[ 
			s (n) = \sigma (n) - n
		\]		
		En el ejemplo anterior, \( s (12) = 28-12 = 16 \).
		
		\subsubsection{Función $\varphi$ de Euler}
		Dos números son relativamente primos (o coprimos) si no tienen divisores en común (es decir, si su MCD es 1). \( \varphi (n) \) se define como la cantidad de enteros positivos menores a \( n \) y coprimos a \( n \). 
		\[ 
			\varphi (n) = \prod (p_{i} - 1) p_{i}^{a_{i}-1}
		\]		
		
\section{Subconjuntos}
Se busca generar todos los subconjuntos de un conjunto de \( n \) elementos. Un conjunto de \( n \) elementos tiene \( 2^{n} \) posibles subconjutos. Cada subconjunto puede representarse como un número \( b \) de \( n \) bits. El elemento \( k \) pertenece al subconjunto si el bit \( k \) de \( b \) está en 1.

Para conjuntos de más de 32 elementos ya no es viable usar esta técnica.
\lstinputlisting[firstline=5, lastline=18]{./src/Subsets.java}
		
\section{Otros}
	\subsection{Ordenamiento de Arrays y Listas}
	Cuando necesite ordenar un vector o una lista, utilice los métodos .sort() que tiene 		Java. El algoritmo que utilizan es QuickSort y su complejidad es \( O(n\log n) \).	
	\lstinputlisting[firstline=7, lastline=15]{./src/Sorting.java}
	
	\subsection{Cola de Prioridad}
	
	\subsection{Interfaz Comparable}
	En ocasiones se puede necesitar ordenar un vector o lista de un tipo de datos definido por el usuario (clase), o utilizar una cola de prioridad. Para hacer esto, la clase debe implementar la interfaz Comparable de Java.
	
	\subsection{Imprimir números decimales redondeados}
	Generalmente basta con esta función de Java para redondear correctamente números decimales.	
	\lstinputlisting[firstline=4, lastline=9]{./src/Redondear.java}
	
	\subsection{BufferedReader y BufferedWriter}
	\emph{Scanner} es sencillo de utilizar pero es lento. Se recomienda utilizar siempre \emph{BufferedReader} para leer entradas.
	
	En algunas ocasiones también se necesitará un modo más rápido que \emph{System.out.println()} para imprimr. \emph{BufferedWriter} es más rápido, nunca está de más usarlo.
	\lstinputlisting[firstline=9, lastline=29]{./src/ReaderWriter.java}
\end{multicols}	
\end{document}